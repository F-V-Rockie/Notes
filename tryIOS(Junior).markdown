## **IOS发展**
> WWDC（苹果全球开发者大会）

## **技术前景**
1. Objective-C
2. Swift

## **Swift语言基础**

### **数据类型**

- 变量与常量

变量：var

常量：let

标识符：以字符（包括Unicode字符）、下划线（_）、美元符（$）开头，不以数字开头，不包含空格，不使用关键字，其长度没有限制

占位符：\\(变量)

- 整形与浮点型

整形Int：可以增加下划线作为分隔符，也可以在数值前添加额外的值

整形之间转换必须是显示转换

浮点型：

+-inf = /0.0

非数nan = 0.0/0.0

- 类型别名：typealias

- 元组类型

定义元祖变量，给定初始值

赋值时必须为所有的成员变量赋值

通过key赋值，顺序可以调换

根据下标输出元素

- 可选类型

可选类型：任何已知类型紧跟?，nil表示值缺失

强制解析：变量或常量后面添加!

**注意：***可选类型的变量和常量确实有值时才能解析成功*

可选绑定：if或while语句中对可选类型的值进行判断，并把值赋给变量或常量

隐式解析可选类型：已有类型后面添加!，适用于被赋值之后不会重新变为nil的变量

- 注释

```
//单行注释

/*
  /*
    多行注释可以嵌套
  */
*/
```
  
### **运算符**

- 赋值运算符

赋值表达式无值

不支持连续赋值

扩展的赋值运算符：+=、-=、*=、/=、&=、\|=

- 算数运算符

求余运算%：结果的正负取决于被除数

- 溢出运算符：&-、&+、&*、&/、&%

- 位运算符

按位与&

按位或\|

按位异或^

按位取反~

按位左位移<<

按位右位移>>

- 区间运算符

左闭右开区间运算符..<

闭区间运算符...

- 比较运算符

结果为bool值

特征相等运算符===

特征不等运算符!==

- 逻辑运算符

与&&

或\|\|

非!

- 三目运算符

- 空合并运算符

nil合并运算符：a ?? b 对可选类型a进行空判断，如果a包含值就进行解封，否则返回默认值b

**注意：**

*表达式a必须是Optical类型，默认值b的类型必须和a存储值的类型保持一致*

*如果a为非空值（non-nil），那么b不会被估值*

- 运算符的结合性和优先级

单目运算符、赋值运算符和三目运算符从右向左结合

### **流程控制**

- 顺序结构

- 分支结构

if语句：条件执行体放在{}中

switch语句：任意case块执行完成后自动终止该switch语句，不用break

每个case块至少包含一条语句

case标签后可以有多个值，用逗号隔开

fallthrough贯穿语句

case块的条件可以是范围或元组

case值绑定：将元组的成员绑定到临时变量

case条件值绑定：where语句

- 循环结构

while循环：先判断，条件为真执行循环体

do while循环：先执行在判断，条件为真继续循环

for_in循环：下划线符号_替代循环变量，忽略具体的值，不提供循环遍历时对值的访问

标签：紧跟冒号的标识符，放在switch语句或循环语句之前起作用

break：结束循环，开始执行循环之后的代码

continue：忽略本次循环剩余语句，执行下一次循环，不终止循环

### **字符和字符串**

- 字符类型及表现形式

单个字符指定字符常量

转义字符表示特殊字符常量

使用\u{n}的Unicode形式，n代表1~8位的十六进制数

必须包含在双引号内

每个字符代表一个可扩展字母集

- 字符串的创建

使用构造器来创建字符串，初始化字符串实例

创建多个重复字符的字符串

- 字符串基本操作

判断字符串是否为空isEmpty

字符串拼接：用+进行拼接 用+=将字符串拼接到自身

通过调用全局countElement函数，将字符串作为参数进行传递，获取该字符串的字符数量

字符串是否可以修改通过定义变量或常量决定

字符串比较==

检查字符串是否拥有特定前缀hasPrefix或后缀hasSuffix：以字符串作为参数传入并穿出Boolean值

### **集合**

#### **数组**

- 数组创建

声明数组写法：Array<SomeType>，[SomeType]

使用构造语法创建由特定数据类型构成的空数组

for_in变量默认是let类型

- 访问和修改数组（数组的可变性）

在数组尾部添加新元素append()

通过加法添加数组元素

替换

不能使用下标语法在数组尾部添加新项，调用insert(atIndex:)方法在某个具体索引值之前添加数据项

使用removeAtIndex方法移除数组中的一项

removeLast方法移除数组中的最后一项

removeAll删除所有元素，参数为是否保留数据缓冲，默认是false

#### **字典**

- 字典的声明和创建

Dictionary<KeyType, valueType>

[KeyType: valueType]

通过变量或常量决定字典是否可变

- 字典的使用

不存在的key，返回为nil

对不存在的key设置value，字典将会添加key-value对

遍历字典时使用元组

updateValue(forKey:)方法在键不存在对应值时设置值或在存在时更新已存在的值，返回更新之前的原值

移除键值：removeAll，removeValueForKey

### **函数**

- 定义和调用函数

```
func 函数名(形参列表) ->返回值类型 {
	可执行语句组成的函数
}
```

- 函数形参

没有参数的函数，()必须有

局部参数：不能再调用函数时使用

外部参数名：局部参数名:形参类型

外部参数和局部参数一样，只需要在局部参数前加#

可变参数：在参数类型后添加...，表示该参数可以接受多个参数值

一个函数只能有一个可变参数

默认参数：默认参数有外部参数名，忽略添加_

可变参数在参数列表的末尾，默认值参数在次后

常量形参：默认形参是常量

变量形参：形参的改变在函数体内部有效

In-Out形参：将值类型参数传入函数内部，强制传递变量的指针

**注意：**

*只能传入变量作为实参*

*输入输出参数不能带有默认值*

*用关键字inout标记的参数不能再用var或let标记*

- 函数返回值

无指定返回返回类型的函数返回void，可以理解为空元组

多个返回值

- 函数类型

函数类型作为变量或常量、参数类型或返回值类型

- 递归函数

- 函数重载

形参列表或返回值类型不同

### **闭包**

闭包是引用类型

- 嵌套函数

函数体内部定义的函数

- 闭包表达式

```
{ (形参列表) -> 返回值类型 in
	可执行表达式
}
```

- 利用上下文推断类型

省略形参名，通过$0, $1...引用第一个、第二个参数

- 捕获上下文中的变量和常量

- 尾随闭包

## **Swift语言基础**

- 面向对象的特点

1. 面向对象的核心：类和对象
2. 面向对象编程的三大特征：封装、继承和多态
3. Swift可定义枚举、结构体和类三种面向对象的类型
4. 支持定义存储属性、计算属性、方法、下标、构造器和嵌套类型

### **枚举**

1. 用于管理一组有限的值的集合
2. 支持计算属性
3. 支持实例方法和类方法
4. 支持定义构造器来完成初始化
5. 支持扩展和协议

- 定义枚举的语法格式

```
enum 枚举名 {
	// 使用case关键字列出所有枚举值
	// 枚举的其它成员
}
```

使用一个case列举所有的值

使用枚举声明变量

使用switch语句判断枚举值：switch中的case没有覆盖枚举的所有值，必须添加default语句

- 原始值

```
enum 枚举名 : 原始值类型 {
	case 枚举值 = 原始值
}
```

rawValue获取原始值：init ? (rawValue:)

- 关联值

将关联值绑定到变量或常量来获取：将关联值提取为变量或常量，只将一个var或let放在枚举成员之前

### **类和结构体**

- 定义类

```
[修饰符] class 类名 {
	零到多个构造器
	零到多个属性
	零到多个方法
	零到多个下标
}
```

修饰符可以是private、public、internal和final

- 定义结构体

```
[修饰符] struct 结构体名 {
	
}
```

修饰符可以是private、public和internal

- 定义属性的语法

```
[修饰符] var或者let 存储属性名 : 类型名字 = 初始值
```

- 定义构造器语法

```
[修饰符] init(形参列表) {
	// 零到多句可执行语句组成的构造器执行体
}
```

- 定义方法的语法

```
[修饰符] func 方法名 (形参列表) -> 返回值类型 {
	// 零到多条可执行语句
}
```

- 创建实例

只有类的实例可以称为对象

- 值类型与引用类型

内存里的对象可以有多个引用，即多个引用变量指向同一个对象

- 引用类型的比较

- self关键字

1. 构造器中的self代表该构造器正在初始化的实例
2. 方法中的self代表该方法的调用者

- 类和结构体的选择

1. 结构体的主要目的是用于封装少量相关的简单数据
2. 如果需要在传递参数或者赋值时自动复制副本，使用结构体
3. 明确该类型无须继承另一个已有的类或被其他类继承

**注意：***大部分时候，程序应该自定义类而不是自定义结构体*

只有类才支持继承，枚举和结构体都不可以

### **存储属性和计算属性**

1. 存储属性：存储在类、结构体里的变量或者常量
2. 分为：实例存储属性、类型存储属性
3. 所有的存储属性必须显式地指定初始值，在定义时或者构造器指定
4. 可选类型的存储属性可以不指定初始值

- 结构体中实例存储属性的规则

1. 程序为所有的实例存储属性指定了初始值，且没有构造器，则系统会提供两个构造器：一个无参数的构造器和一个初始化所有实例存储属性的构造器
2. 没有初始值和构造器，系统提供一个初始化所有实例存储属性的构造器，通过构造器参数完成实例存储属性的初始化
3. 有构造器，则程序必须为结构体中的所有存储属性提供初始值

定义常量存储属性，可以不指定初始值

- 结构体常量与实例属性

延迟存储属性：第一次被调用时候才会被计算初始值的属性，用lazy修饰符

- 定义计算属性

```
[修饰符] var 计算属性名 : 属性类型 {
	get {
		// getter方法执行体，该方法一定要有返回值
	}
	set (形参名) {
		// setter方法执行体，该方法一定不能有返回值
	}
}
```

只读属性，则无需set部分，可以省略get和花括号

- 属性观察者

1. 除了延迟存储属性之外的所有存储属性（包括实例存储属性和类型存储属性）
2. 可通过重载方式为继承得到的属性（包括存储属性和计算属性）添加属性观察者

```
[修饰符] var 计算属性名 : 属性类型 = 初始值 {
	willSet (newValue) {
		// 被观察的属性即将被赋值之前自动调用的方法
	}
	didSet (oldValue) {
		// 被观察的属性赋值完成之后自动调用的方法
	}
}
```

**注意：***willSet和didSet的参数名可以省略*

### **方法**

- 方法的所属性

1. 定义方法需要在类型（枚举、结构体、类）里定义，不能独立定义
2. 方法属于该类型本身或者是该类型的一个实例
3. 不能独立执行方法，执行方法必须使用类型或实例作为调用着

**注意：***枚举、结构体中方法使用static修饰，类中用class修饰，都属于类型方法，否则的话属于实例方法*

- 将方法转换为函数

- 方法的外部形参名

默认为除第一个参数外都添加了外部参数名，与局部参数名一样，如果不需要，则用_ 下划线的方式去掉

- 值类型的可变方法

将mutating关键字放在func之前，即将该方法声明为可变方法

**注意：***常量类型的结构体、枚举是不可变的*

- 属性和方法的统一

使用函数类型定义存储属性，并将函数或者闭包作为该属性的初始值，这个属性就成了方法

### **下标**

1. 所有的类型（枚举、类和结构体）都支持定义下标
2. 同一个类型可以定义多个下标
3. 通过下标的形参列表或者返回值类型区分不同的下标
4. 同一类型中定义多个不同的下标被称为下标重载

- 下标的基本用法

```
Subscripe(形参列表) -> 下标返回值类型 {
	get {
		// getter方法执行体，该方法必须有返回值
	}
	set (形参名) {
		// setter方法执行体，该方法不能有返回值
	}
}
```

- 下标语法格式说明

1. 形参列表：与函数的形参列表的用法基本相同，但是不支持指定外部参数和默认值
2. 下标的返回值类型：可以是任何有效的类型

- 下标重载

### **可选链**

1. 用于处理可选类型的属性、方法和下标
2. 使用可选链代替强制解析
3. 调用方法
4. 访问下标

- 使用可选链访问属性

1. 可选链访问方式：将强制解析的感叹号换成?，在隐式解析的后面也添加?后缀
2. 可选链会自动判断程序访问的关联实例是否为nil

### **类型属性和类型方法**

1. 类型可以定义定义5种成员：属性、方法、下标、构造器和嵌套类型
2. 类型属性、实例属性
3. 类型方法、实例方法
4. static：在枚举、结构体中修饰的属性、方法
5. class：在类中修饰的属性、方法

- 值类型的类型属性

**注意：***结构体可以包含实例计算属性，不能包含实例存储属性*

- 类的类型属性

**注意：***类中不可以定义类型存储属性，只能包含类型计算属性*

- 值类型的类型方法

- 类的类型方法

### **构造器**








