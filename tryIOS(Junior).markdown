## **IOS发展**
> WWDC（苹果全球开发者大会）

## **技术前景**
1. Objective-C
2. Swift

## **Swift语言基础**

### **数据类型**

- 变量与常量

变量：var

常量：let

标识符：以字符（包括Unicode字符）、下划线（_）、美元符（$）开头，不以数字开头，不包含空格，不使用关键字，其长度没有限制

占位符：\\(变量)

- 整形与浮点型

整形Int：可以增加下划线作为分隔符，也可以在数值前添加额外的值

整形之间转换必须是显示转换

浮点型：

+-inf = /0.0

非数nan = 0.0/0.0

- 类型别名：typealias

- 元组类型

定义元祖变量，给定初始值

赋值时必须为所有的成员变量赋值

通过key赋值，顺序可以调换

根据下标输出元素

- 可选类型

可选类型：任何已知类型紧跟?，nil表示值缺失

强制解析：变量或常量后面添加!

**注意：***可选类型的变量和常量确实有值时才能解析成功*

可选绑定：if或while语句中对可选类型的值进行判断，并把值赋给变量或常量

隐式解析可选类型：已有类型后面添加!，适用于被赋值之后不会重新变为nil的变量

- 注释

```
//单行注释

/*
  /*
    多行注释可以嵌套
  */
*/
```
  
### **运算符**

- 赋值运算符

赋值表达式无值

不支持连续赋值

扩展的赋值运算符：+=、-=、*=、/=、&=、\|=

- 算数运算符

求余运算%：结果的正负取决于被除数

- 溢出运算符：&-、&+、&*、&/、&%

- 位运算符

按位与&

按位或\|

按位异或^

按位取反~

按位左位移<<

按位右位移>>

- 区间运算符

左闭右开区间运算符..<

闭区间运算符...

- 比较运算符

结果为bool值

特征相等运算符===

特征不等运算符!==

- 逻辑运算符

与&&

或\|\|

非!

- 三目运算符

- 空合并运算符

nil合并运算符：a ?? b 对可选类型a进行空判断，如果a包含值就进行解封，否则返回默认值b

**注意：**

*表达式a必须是Optical类型，默认值b的类型必须和a存储值的类型保持一致*

*如果a为非空值（non-nil），那么b不会被估值*

- 运算符的结合性和优先级

单目运算符、赋值运算符和三目运算符从右向左结合

### **流程控制**

- 顺序结构

- 分支结构

if语句：条件执行体放在{}中

switch语句：任意case块执行完成后自动终止该switch语句，不用break

每个case块至少包含一条语句

case标签后可以有多个值，用逗号隔开

fallthrough贯穿语句

case块的条件可以是范围或元组

case值绑定：将元组的成员绑定到临时变量

case条件值绑定：where语句

- 循环结构

while循环：先判断，条件为真执行循环体

do while循环：先执行在判断，条件为真继续循环

for_in循环：下划线符号_替代循环变量，忽略具体的值，不提供循环遍历时对值的访问

标签：紧跟冒号的标识符，放在switch语句或循环语句之前起作用

break：结束循环，开始执行循环之后的代码

continue：忽略本次循环剩余语句，执行下一次循环，不终止循环

### **字符和字符串**

- 字符类型及表现形式

单个字符指定字符常量

转义字符表示特殊字符常量

使用\u{n}的Unicode形式，n代表1~8位的十六进制数

必须包含在双引号内

每个字符代表一个可扩展字母集

- 字符串的创建

使用构造器来创建字符串，初始化字符串实例

创建多个重复字符的字符串

- 字符串基本操作

判断字符串是否为空isEmpty

字符串拼接：用+进行拼接 用+=将字符串拼接到自身

通过调用全局countElement函数，将字符串作为参数进行传递，获取该字符串的字符数量

字符串是否可以修改通过定义变量或常量决定

字符串比较==

检查字符串是否拥有特定前缀hasPrefix或后缀hasSuffix：以字符串作为参数传入并穿出Boolean值

### **集合**

#### **数组**

- 数组创建

声明数组写法：Array<SomeType>，[SomeType]

使用构造语法创建由特定数据类型构成的空数组

for_in变量默认是let类型

- 访问和修改数组（数组的可变性）

在数组尾部添加新元素append()

通过加法添加数组元素

替换

不能使用下标语法在数组尾部添加新项，调用insert(atIndex:)方法在某个具体索引值之前添加数据项

使用removeAtIndex方法移除数组中的一项

removeLast方法移除数组中的最后一项

removeAll删除所有元素，参数为是否保留数据缓冲，默认是false

#### **字典**

- 字典的声明和创建

Dictionary<KeyType, valueType>

[KeyType: valueType]

通过变量或常量决定字典是否可变

- 字典的使用

不存在的key，返回为nil

对不存在的key设置value，字典将会添加key-value对

遍历字典时使用元组

updateValue(forKey:)方法在键不存在对应值时设置值或在存在时更新已存在的值，返回更新之前的原值

移除键值：removeAll，removeValueForKey

### **函数**

- 定义和调用函数

```
func 函数名(形参列表) ->返回值类型 {
	可执行语句组成的函数
}
```

- 函数形参

没有参数的函数，()必须有

局部参数：不能再调用函数时使用

外部参数名：局部参数名:形参类型

外部参数和局部参数一样，只需要在局部参数前加#

可变参数：在参数类型后添加...，表示该参数可以接受多个参数值

一个函数只能有一个可变参数

默认参数：默认参数有外部参数名，忽略添加_

可变参数在参数列表的末尾，默认值参数在次后

常量形参：默认形参是常量

变量形参：形参的改变在函数体内部有效

In-Out形参：将值类型参数传入函数内部，强制传递变量的指针

**注意：**

*只能传入变量作为实参*

*输入输出参数不能带有默认值*

*用关键字inout标记的参数不能再用var或let标记*

- 函数返回值

无指定返回返回类型的函数返回void，可以理解为空元组

多个返回值

- 函数类型

函数类型作为变量或常量、参数类型或返回值类型

- 递归函数

- 函数重载

形参列表或返回值类型不同

### **闭包**

闭包是引用类型

- 嵌套函数

函数体内部定义的函数

- 闭包表达式

```
{ (形参列表) -> 返回值类型 in
	可执行表达式
}
```

- 利用上下文推断类型

省略形参名，通过$0, $1...引用第一个、第二个参数

- 捕获上下文中的变量和常量

- 尾随闭包

## **Swift语言基础**

- 面向对象的特点

1. 面向对象的核心：类和对象
2. 面向对象编程的三大特征：封装、继承和多态
3. Swift可定义枚举、结构体和类三种面向对象的类型
4. 支持定义存储属性、计算属性、方法、下标、构造器和嵌套类型

### **枚举**

1. 用于管理一组有限的值的集合
2. 支持计算属性
3. 支持实例方法和类方法
4. 支持定义构造器来完成初始化
5. 支持扩展和协议

- 定义枚举的语法格式

```
enum 枚举名 {
	// 使用case关键字列出所有枚举值
	// 枚举的其它成员
}
```

使用一个case列举所有的值

使用枚举声明变量

使用switch语句判断枚举值：switch中的case没有覆盖枚举的所有值，必须添加default语句

- 原始值

```
enum 枚举名 : 原始值类型 {
	case 枚举值 = 原始值
}
```

rawValue获取原始值：init ? (rawValue:)

- 关联值

将关联值绑定到变量或常量来获取：将关联值提取为变量或常量，只将一个var或let放在枚举成员之前

### **类和结构体**

- 定义类

```
[修饰符] class 类名 {
	零到多个构造器
	零到多个属性
	零到多个方法
	零到多个下标
}
```

修饰符可以是private、public、internal和final

- 定义结构体

```
[修饰符] struct 结构体名 {
	
}
```

修饰符可以是private、public和internal

- 定义属性的语法

```
[修饰符] var或者let 存储属性名 : 类型名字 = 初始值
```

- 定义构造器语法

```
[修饰符] init(形参列表) {
	// 零到多句可执行语句组成的构造器执行体
}
```

- 定义方法的语法

```
[修饰符] func 方法名 (形参列表) -> 返回值类型 {
	// 零到多条可执行语句
}
```

- 创建实例

只有类的实例可以称为对象

- 值类型与引用类型

内存里的对象可以有多个引用，即多个引用变量指向同一个对象

- 引用类型的比较

- self关键字

1. 构造器中的self代表该构造器正在初始化的实例
2. 方法中的self代表该方法的调用者

- 类和结构体的选择

1. 结构体的主要目的是用于封装少量相关的简单数据
2. 如果需要在传递参数或者赋值时自动复制副本，使用结构体
3. 明确该类型无须继承另一个已有的类或被其他类继承

**注意：***大部分时候，程序应该自定义类而不是自定义结构体*

只有类才支持继承，枚举和结构体都不可以

### **存储属性和计算属性**

1. 存储属性：存储在类、结构体里的变量或者常量
2. 分为：实例存储属性、类型存储属性
3. 所有的存储属性必须显式地指定初始值，在定义时或者构造器指定
4. 可选类型的存储属性可以不指定初始值

- 结构体中实例存储属性的规则

1. 程序为所有的实例存储属性指定了初始值，且没有构造器，则系统会提供两个构造器：一个无参数的构造器和一个初始化所有实例存储属性的构造器
2. 没有初始值和构造器，系统提供一个初始化所有实例存储属性的构造器，通过构造器参数完成实例存储属性的初始化
3. 有构造器，则程序必须为结构体中的所有存储属性提供初始值

定义常量存储属性，可以不指定初始值

- 结构体常量与实例属性

延迟存储属性：第一次被调用时候才会被计算初始值的属性，用lazy修饰符

- 定义计算属性

```
[修饰符] var 计算属性名 : 属性类型 {
	get {
		// getter方法执行体，该方法一定要有返回值
	}
	set (形参名) {
		// setter方法执行体，该方法一定不能有返回值
	}
}
```

只读属性，则无需set部分，可以省略get和花括号

- 属性观察者

1. 除了延迟存储属性之外的所有存储属性（包括实例存储属性和类型存储属性）
2. 可通过重载方式为继承得到的属性（包括存储属性和计算属性）添加属性观察者

```
[修饰符] var 计算属性名 : 属性类型 = 初始值 {
	willSet (newValue) {
		// 被观察的属性即将被赋值之前自动调用的方法
	}
	didSet (oldValue) {
		// 被观察的属性赋值完成之后自动调用的方法
	}
}
```

**注意：***willSet和didSet的参数名可以省略*

### **方法**

- 方法的所属性

1. 定义方法需要在类型（枚举、结构体、类）里定义，不能独立定义
2. 方法属于该类型本身或者是该类型的一个实例
3. 不能独立执行方法，执行方法必须使用类型或实例作为调用着

**注意：***枚举、结构体中方法使用static修饰，类中用class修饰，都属于类型方法，否则的话属于实例方法*

- 将方法转换为函数

- 方法的外部形参名

默认为除第一个参数外都添加了外部参数名，与局部参数名一样，如果不需要，则用_ 下划线的方式去掉

- 值类型的可变方法

将mutating关键字放在func之前，即将该方法声明为可变方法

**注意：***常量类型的结构体、枚举是不可变的*

- 属性和方法的统一

使用函数类型定义存储属性，并将函数或者闭包作为该属性的初始值，这个属性就成了方法

### **下标**

1. 所有的类型（枚举、类和结构体）都支持定义下标
2. 同一个类型可以定义多个下标
3. 通过下标的形参列表或者返回值类型区分不同的下标
4. 同一类型中定义多个不同的下标被称为下标重载

- 下标的基本用法

```
Subscripe(形参列表) -> 下标返回值类型 {
	get {
		// getter方法执行体，该方法必须有返回值
	}
	set (形参名) {
		// setter方法执行体，该方法不能有返回值
	}
}
```

- 下标语法格式说明

1. 形参列表：与函数的形参列表的用法基本相同，但是不支持指定外部参数和默认值
2. 下标的返回值类型：可以是任何有效的类型

- 下标重载

### **可选链**

1. 用于处理可选类型的属性、方法和下标
2. 使用可选链代替强制解析
3. 调用方法
4. 访问下标

- 使用可选链访问属性

1. 可选链访问方式：将强制解析的感叹号换成?，在隐式解析的后面也添加?后缀
2. 可选链会自动判断程序访问的关联实例是否为nil

### **类型属性和类型方法**

1. 类型可以定义定义5种成员：属性、方法、下标、构造器和嵌套类型
2. 类型属性、实例属性
3. 类型方法、实例方法
4. static：在枚举、结构体中修饰的属性、方法
5. class：在类中修饰的属性、方法

- 值类型的类型属性

**注意：***结构体可以包含实例计算属性，不能包含实例存储属性*

- 类的类型属性

**注意：***类中不可以定义类型存储属性，只能包含类型计算属性*

- 值类型的类型方法

- 类的类型方法

### **构造器**

1. 构造器构造出来的实例由系统隐式返回
2. 构造器的作用完成每个类、构造体中实例存储属性的初始化
3. 为实例存储属性赋初始值的时机：
  1. 定义实例存储属性时指定初始值
  2. 在构造器中为实例存储属性指定初始值

- 实例存储属性的初始化分类

1. 定义实例存储属性时显式指定了初始值
2. 实例存储属性的类型为可选类型
3. 系统提供的默认构造器为实例存储属性分配初始值
4. 显式提供的构造器为实例存储属性分配初始值

- 类和结构体的构造器

1. 为类提供一个无参数的构造器
2. 为结构体提供两个构造器：无参数的构造器和初始化所有实例存储属性的构造器

- 可能失败的构造器

1. 使用init?或者init!关键字进行定义
2. 在构造器执行体中使用return nil来表示构造器失败
3. 不允许定义两个相同形参列表的构造器，即使一个是可能失败的构造器，一个是普通的构造器也不行

- 构造器的外部形参名

- 取消构造器的外部形参名

- 在构造过程中常量属性是可以修改的

- 使用闭包或者函数为属性设置初始值

- 值类型的构造器重载

- 构造器代理：在定义构造器时，通过self.init(实参)调用其他构造器来完成实例的部分构造过程

### **继承**

- 继承的特点

1. 单继承，每个子类只有一个直接父类
2. 子类继承父类，可以获得父类的属性、方法、下标，也可以进行重写
3. Swift的类并不是从一个通用的基类继承而来的

- 重写父类的方法

override修饰被重写的部分

- 重写父类的属性

- 重写属性观察者

- 重写父类的下标

- 使用final防止重写

final修饰的类不能被继承，属性、方法和下标不能被重写

### **多态**

1. Swift引用变量有两个类型：编译时类型、运行时类型
2. 编译时类型由声明该变量时使用类型决定
3. 运行时类型由实际赋值给该变量的实例决定
4. 相同类型的变量，调用同一个方法时呈现出多种不同的行为特征

- 使用is运算符检查类型

1. 返回值为布尔类型
2. 前一个操作数是一个引用类型变量，后一个操作数是一个类
3. 运算符前面操作数的编译类型要么与后面的类相同，要么具有继承关系，否则编译报错

### **向下转型与嵌套类型**

- 使用as运算符向下转型

1. 向上转型：把一个子类实例直接赋给一个父类引用变量、不用任何类型转换
2. 引用变量只能调用其编译时类型的方法，强制转换为其实际类型，可以调用运行时类型的方法，这种强制转换为向下转型
3. 向下转型运算符：
  1. as: 强制将运算符前面的引用变量转换成后面的类型
  2. as? 可选形式的向下转换
4. 向下转换只能在具有继承关系的两个类型之间进行

- Any和AnyObject

1. AnyObject：可代表任何类的实例
2. Any：可代表任何类型，包括Int、Double等值类型，AnyObject修饰的实例

- 嵌套类型

1. 在一个类型的内部定义另一个类型
2. Swift的枚举、类、结构体都可以定义嵌套类型
3. Swift的嵌套类型支持多级嵌套
4. 嵌套类型不允许使用static或者class修饰

使用嵌套类型时，需要以被嵌套的名字为前缀

### **扩展**

- 特性

1. 使用扩展添加属性、方法、可变方法、构造器、下标、嵌套类型
2. 可以使一个已有类型符合一个或者多个协议
3. Swift的扩展与Objective-C的类目（Category）类似，只是Swift中的扩展没有名字
4. 扩展并不是派生子类，因此不支持重写

- 语法定义

```
[修饰符] extension 已有类型 {
	// 添加新功能
}
```

修饰符可以省略，或者是private、internal、public其中之一，类型可以是枚举、结构体和类其中之一

**注意：***通过扩展为已有类型添加了新功能，那这个新功能在该类型的所有已有实例中都是可用的*

通过扩展让已有的类型遵守一个或者多个协议

```
[修饰符] extension 已有协议：协议1，协议2 {
	// 添加新功能
}
```

- 使用扩展添加属性、方法、可变方法、构造器、下标、嵌套类型

1. 使用扩展可以添加3种属性
  1. 类型存储属性
  2. 实例计算属性
  3. 类型计算属性
2. 使用扩展可以添加实例方法或者类型方法

### **协议**

1. Swift协议用于定义多个类型应该遵守的规范
2. 协议定义了一种规范，不提供任何实现
3. 协议统一了属性名、方法、下标，但是协议并不提供任何实现
4. 语法格式：
```
[修饰符] protocol 协议名: 父协议1, 父协议2, ... {
	// 协议内容
}
```

- 语法说明

1. 修饰符：可以省略，也可以是private、internal、public之一
2. 协议名应与类名采用相同的命名规则
3. 一个协议可以有多个直接父协议，但协议只能继承协议，不能继承类
4. 协议内容：指定协议实现者必须提供的那些功能，比如属性、方法、构造器和下标等

- 实现协议的语法

1. 
```
Struct 结构体名: 第一个协议, 第二个协议, ... {
	// 实现协议要求
}
```
2. 
```
Class 类名: SuperClass, 第一个协议, 第二个协议, ...{
	
}
```

- 协议指定的属性要求

1. 协议中定义属性要求的语法格式：
```
class var 属性名: 类型 { get set }
```

说明：class：可有可无。如果有class关键字，说明为类型属性，否则为实例属性。不可以使用static代替class；

get和set部分：只需写get和set即可，无须提供实现。set可有可无